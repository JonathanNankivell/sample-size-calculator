# Generalised Sample Size Calculations


## Prerequisits

### Define bandits

```{r}

balanced <- function( i, j, k, l, chooser_params ) {

    n <- i + j + k + l

    if (n%%2) {
        action <- sample(c(1,2), size=1)
    }
    else {
        if (i + j < k + l) {
            action <- 1
        } else {
            action <- 2
        }
    }

    return(action)
}


thomper <- function( i, j, k, l, chooser_params ) {

    sample.c <- rbeta(1, i + prior.i, j + prior.j)
    sample.n <- rbeta(1, k + prior.k, l + prior.l)

    if (sample.c > sample.n) {
        return(1)
    } else {
       return(2)
    }
}


foo <- function(i,j,k,l) {
    # https://gwern.net/doc/statistics/decision/1933-thompson.pdf
    numer <- 0

    for (a in 0:(i)) {
        numer <- numer + (choose(i + k - a, k) * choose(j + l + 1 + a, l))
    }
    denom <- choose(i + j + k + l + 2, k + l + 1)
    sum <- numer / denom

    return(sum)
}


tw_foo <- function( i, j, k, l, chooser_params ) {

    c <- chooser_params

    prob <- tryCatch(
        {
            min(foo(i + prior.i, j + prior.j, k + prior.k, l + prior.l),1)
        },
        error=function(cond) {
            expected.c <- (i + prior.i)/(i + prior.i + j + prior.j)
            expected.n <- (k + prior.k)/(k + prior.k + l + prior.l)

            if (expected.c > expected.n) {
                1
            } else {
                0
            }
        }
    )

    if (is.na(prob)) {
        sample.c <- rbeta(1, i + prior.i, j + prior.j)
        sample.n <- rbeta(1, k + prior.k, l + prior.l)

        if (sample.c > sample.n) {
            prob <- 1
        } else {
            prob <- 0
        }
    }

    quant <- (prob**c)/(prob**c + (1-prob)**c)

    #print(paste("c:",c,"prob:",prob,"quant:",quant,"i:", i, "j:",j ,"k:", k,"l:", l))
    if (is.na(quant)) {
        print(paste(i,j,k,l))
    }

    action <- sample(c(1,2), 1, prob = c(quant,1-quant))

    return(action)
}


```


### Trial Infrastructure

```{r}

one_run <- function(n, chooser, chooser_params, alpha) {

    i <- 0
    j <- 0
    k <- 0
    l <- 0

    # set the true probability of success
    p.c <- rbeta( 1, prior.i, prior.j )
    p.n <- rbeta( 1, prior.k, prior.l )

    correctly_reject_nulls <- c()

    for (m in 1:n) {

        # use the chooser function to pick an action
        # in this case, it should return 1 or 2
        action <- chooser( i, j, k, l, chooser_params )
        if (length(action)!=1) {
            chooser_params <- action[2]
            action <- action[1]
        }

        if (action == 1) {

            # decide whether or not the treatment is a success
            sample <- rbinom(1, 1, p.c)

            if (sample == 1) {
                # success!
                i <- i + 1
            } else if (sample == 0) {
                # failure
                j <- j + 1
            }
        } else {
            
            # decide whether or not the treatment is a success
            sample <- rbinom(1, 1, p.n)

            if (sample == 1) {
                # success!
                k <- k + 1
            } else if (sample == 0) {
                # failure
                l <- l + 1
            }
        }

        xtab <- as.table(rbind(c(i, j), c(k, l)))
        dimnames(xtab) <- list(
            group = c("grp1", "grp2"),
            success = c("yes", "no")
        )

        null_rejected <- tryCatch(
            {
                test <- prop.test(xtab)
                test["p.value"] < alpha
            },
            error=function(cond) {
                FALSE
            }
        )
        if (is.na(null_rejected)) {
            null_rejected <- FALSE
        }
        # power is based on _correctly_ rejecting the null
        # we must ignore rejections where the sign is wrong
        p.c_hat <- i/(i+j)
        p.n_hat <- k/(k+l)
        incorrect_direction <- (p.c_hat > p.n_hat) != (p.c > p.n)
        correctly_reject_null <- null_rejected
        if (null_rejected & incorrect_direction) {
            correctly_reject_null <- FALSE
        }

        correctly_reject_nulls <- append(correctly_reject_nulls, correctly_reject_null)
    }

    return(correctly_reject_nulls)
}


simulator <- function(numb_of_sims, numb_of_patients, runner, chooser, chooser_params, alpha) {

    runs <- array(0, dim=numb_of_patients)
    props <- c()

    for (iter in 1:(numb_of_sims)) {
        
        correctly_reject_nulls <- runner(numb_of_patients, chooser, chooser_params, alpha)
        runs <- runs + (correctly_reject_nulls - runs)/(iter+1)
    }

    return(c(runs, props))
}

```

## Body

```{r}

# setup parameters
numb_of_sims <- 50
numb_of_patients <- 100000

prior.i <- 100
prior.j <- 100
prior.k <- 3
prior.l <- 1

power_threshold <- 0.8
alpha <- 0.05

# plot beta distributions
x1 <- seq(0, 1, length=1000)
y1 <- dbeta(x1, prior.i, prior.j)
plot(x1, y1, type="l", col="red", main="Plot of Priors", ylab="Probability density", xlab="Actual Proportion")

x2 <- seq(0, 1, length=1000)
y2 <- dbeta(x1, prior.k, prior.l)
lines(x2, y2, col="blue")
legend(x="topright", legend=c(paste0("Beta(",prior.i,",",prior.j,")"), paste0("Beta(",prior.k,",",prior.l,")")), lty=1, col=c("red", "blue"))

```




```{r}

# simulate the clinical trials
y <- simulator(numb_of_sims, numb_of_patients, one_run, tw_foo, 0.5, alpha)

```

```{r}

# plot the expected power for each sample size

png("sample size vs power for TW(0.5); B(100,100) & B(1,3).png", units = "in", width = 5, height = 4, res = 300)

x <- 1:numb_of_patients

plot(x,y, ylim=c(0,1), cex=0.25, ylab="Expected power",xlab="Sample size",main="Sample Size vs Power for TW(0.5)")

# find the sample size that give the power_threshold set earlier
abline(h=power_threshold)
optimal_sample_size <- sum(y < power_threshold); optimal_sample_size
abline(v=optimal_sample_size)

dev.off()

```



